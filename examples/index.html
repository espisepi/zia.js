<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Zia.js - Examples</title>
    <meta charset="utf-8">
    <style>
      body {
        margin: 0px;
        background-color: #FFFFFF;
        overflow: hidden;
      }
    </style>
    <script src="../build/zia.js"></script>

    <!-- Fragment shader program -->

    <script id="shader-fs" type="x-shader/x-fragment">
      varying highp vec2 vTextureCoord;
      
      uniform sampler2D uSampler;
      
      void main(void) {
        gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
      }
    </script>
    
    <!-- Vertex shader program -->
    
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;
    
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      
      varying highp vec2 vTextureCoord;
    
      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
      }
    </script>
  </head>
  <body>
    <canvas id="mainCanvas" width="800" height="600"></canvas>

    <script>

      function createVertexBuffer(graphicsDevice) {
        var vertexDeclaration = new Zia.VertexDeclaration([
          new Zia.VertexElement("aVertexPosition", 3)
        ]);
        var vertexBuffer = new Zia.VertexBuffer(graphicsDevice, vertexDeclaration);
        vertexBuffer.setData(new Float32Array(
          [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,
            
            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,
            
            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,
            
            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,
            
            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,
            
            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
          ]));
        return vertexBuffer;
      }

      function createTextureCoordinates(graphicsDevice) {
        var vertexDeclaration = new Zia.VertexDeclaration([
          new Zia.VertexElement("aTextureCoord", 2)
        ]);
        var vertexBuffer = new Zia.VertexBuffer(graphicsDevice, vertexDeclaration);
        vertexBuffer.setData(new Float32Array(
          [
            // Front
            0.0,  0.0,
            1.0,  0.0,
            1.0,  1.0,
            0.0,  1.0,
            // Back
            0.0,  0.0,
            1.0,  0.0,
            1.0,  1.0,
            0.0,  1.0,
            // Top
            0.0,  0.0,
            1.0,  0.0,
            1.0,  1.0,
            0.0,  1.0,
            // Bottom
            0.0,  0.0,
            1.0,  0.0,
            1.0,  1.0,
            0.0,  1.0,
            // Right
            0.0,  0.0,
            1.0,  0.0,
            1.0,  1.0,
            0.0,  1.0,
            // Left
            0.0,  0.0,
            1.0,  0.0,
            1.0,  1.0,
            0.0,  1.0
          ]));
        return vertexBuffer;
      }

      function createIndexBuffer(graphicsDevice) {
        var indexBuffer = new Zia.IndexBuffer(graphicsDevice);
        indexBuffer.setData(new Uint16Array(
          [
            0,  1,  2,      0,  2,  3,    // front
            4,  5,  6,      4,  6,  7,    // back
            8,  9,  10,     8,  10, 11,   // top
            12, 13, 14,     12, 14, 15,   // bottom
            16, 17, 18,     16, 18, 19,   // right
            20, 21, 22,     20, 22, 23    // left
          ]));
        return indexBuffer;
      }

      document.addEventListener('DOMContentLoaded', function () {
        
        var canvas = document.getElementById('mainCanvas');
        
        var graphicsDevice = new Zia.GraphicsDevice(canvas);

        var vertexShader = new Zia.VertexShader(graphicsDevice, document.getElementById('shader-vs').textContent);
        var fragmentShader = new Zia.FragmentShader(graphicsDevice, document.getElementById('shader-fs').textContent);
        var program = new Zia.Program(graphicsDevice, vertexShader, fragmentShader);

        var texture = Zia.Texture.createFromImagePath(graphicsDevice, 'textures/UV_Grid_Sm.jpg');

        var vertexBuffer = createVertexBuffer(graphicsDevice);
        var texCoordsBuffer = createTextureCoordinates(graphicsDevice);

        var indexBuffer = createIndexBuffer(graphicsDevice);

        var projectionMatrix = new Zia.Matrix4().makePerspective(45, 800/600, 0.1, 100);
        var viewMatrix = new Zia.Matrix4().makeTranslation(0, 0, -6);
        var modelMatrix = new Zia.Matrix4().identity();

        var lastCubeUpdateTime, cubeRotation = 0;
        var rotationAxis = new Zia.Vector3(1, 0, 1).normalize();
        var modelViewMatrix = new Zia.Matrix4();

        function drawScene() {
          graphicsDevice.clear(
            Zia.ClearOptions.ColorBuffer | Zia.ClearOptions.DepthBuffer,
            new Zia.Color4(0, 0, 0, 1), 1);

          graphicsDevice.setIndexBuffer(indexBuffer);
          graphicsDevice.setVertexBuffers([vertexBuffer, texCoordsBuffer]);
          graphicsDevice.setProgram(program);

          program.begin();

          modelMatrix.makeRotationAxis(rotationAxis, cubeRotation);

          modelViewMatrix.multiplyMatrices(viewMatrix, modelMatrix);

          program.setUniform('uSampler', texture);
          program.setUniform('uMVMatrix', modelViewMatrix);
          program.setUniform('uPMatrix', projectionMatrix);

          graphicsDevice.drawIndexedPrimitives(
            Zia.PrimitiveType.TriangleList,
            0, 36);

          program.end();

          var currentTime = (new Date).getTime();
          if (lastCubeUpdateTime) {
            var delta = currentTime - lastCubeUpdateTime;
            
            cubeRotation += (30 * delta) / 100000.0;
          }
          
          lastCubeUpdateTime = currentTime;

          requestAnimationFrame(drawScene);
        }

        requestAnimationFrame(drawScene);

      }, false);

    </script>
  </body>
</html>